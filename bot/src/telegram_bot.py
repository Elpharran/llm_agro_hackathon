from __future__ import annotations

import pandas as pd
from src.logger_download import logger
from src.report_builder import ERROR_TEXT, ReportBuilder
from src.utils import (
    MistralAPIInference,
    edit_message_with_retry,
    error_handler,
    get_reply_text,
    is_allowed,
    manage_attachment,
    message_text,
)
from telegram import (
    BotCommand,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    Update,
    constants,
)
from telegram.ext import (
    Application,
    ApplicationBuilder,
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)


class AgroReportTelegramBot:
    """
    Class representing a CISM-LLM Telegram Bot.
    """

    def __init__(self, builder: ReportBuilder):
        """
        Initializes the bot with the given configuration and LLM bot object.
        :param config: A dictionary containing the bot configuration
        :param openai: LLMHelper object
        """

        self.builder = builder
        self.config = self.builder.config
        self.model = MistralAPIInference(
            config_path="src/configs/mistral_api.cfg.yml",
            api_key=self.builder.config["mistral_api_key"],
            proxy_url=None,
        )
        self.commands = [
            BotCommand(
                command="help",
                description=get_reply_text("help_description"),
            ),
        ]

    async def help(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Shows the help menu.
        """
        if not await self.check_allowed(update, context):
            return

        commands = self.commands
        commands_description = [
            f"/{command.command} - {command.description}" for command in commands
        ]
        help_text = ""
        for text in get_reply_text("help_text"):
            help_text += f"{text}\n\n"

        help_text += "\n".join(commands_description)
        await update.message.reply_text(
            help_text,
            parse_mode=constants.ParseMode.MARKDOWN,
            disable_web_page_preview=True,
        )

    async def check_allowed(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
    ) -> bool:
        """
        Checks if the user is allowed to use the bot
        :param update: Telegram update object
        :param context: Telegram context object
        :return: Boolean indicating if the user is allowed to use the bot
        """
        name = update.message.from_user.name
        user_id = update.message.from_user.id

        if not await is_allowed(self.config, update, context):
            logger.warning(f"User {name} (id: {user_id}) is not allowed to use the bot")
            await self.send_disallowed_message(update, context)
            return False

        return True

    async def send_disallowed_message(
        self, update: Update, _: ContextTypes.DEFAULT_TYPE
    ):
        """
        Sends the disallowed message to the user.
        """
        await update.effective_message.reply_text(
            text=get_reply_text("disallowed"),
            disable_web_page_preview=True,
        )

    async def button_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()

        if query.data == "final_yes":
            corrected_entries = context.user_data.get("corrected_entries")
            if corrected_entries is not None:

                # TODO: —Å–æ—Ö—Ä–∞–Ω—è–ª–∫–∞ –æ—Ç—á–µ—Ç–æ–≤ —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–π –¥–∞—Ç–∫–æ–π

                pass

            # TODO —Å–æ—Ö—Ä–∞–Ω—è–ª–∫–∞ –æ—Ç—á–µ—Ç–æ–≤ –æ–±—ã—á–Ω–∞—è

            await context.bot.send_message(
                chat_id=query.message.chat_id,
                text="–û—Ç—á—ë—Ç –∑–∞–ø–∏—Å–∞–Ω –≤ —Å–≤–æ–¥–Ω—É—é —Ç–∞–±–ª–∏—Ü—É ‚úÖ",
                reply_to_message_id=query.message.message_id,
            )

        elif query.data == "final_no":
            await context.bot.send_message(
                chat_id=query.message.chat_id,
                text="–û—Ç—á—ë—Ç –Ω–µ –∑–∞–ø–∏—Å–∞–Ω –≤ —Å–≤–æ–¥–Ω—É—é —Ç–∞–±–ª–∏—Ü—É ‚ö†Ô∏è",
                reply_to_message_id=query.message.message_id,
            )

        context.user_data.pop("corrected_entries", None)
        await query.edit_message_reply_markup(reply_markup=None)

    async def prompt(self, update: Update, context: ContextTypes.DEFAULT_TYPE):

        if update.edited_message or not update.message or update.message.via_bot:
            return

        if not await self.check_allowed(update, context):
            return

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        if context.user_data.get("awaiting_correction"):
            user_input = update.message.text
            if not user_input:
                await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ.")
                return

            user_input = user_input.strip()
            correction_data = context.user_data.get("corrections")
            if not correction_data:
                context.user_data.pop("awaiting_correction", None)
                return

            current_index = correction_data["current_index"]
            queue = correction_data["queue"]
            entries = correction_data["entries"]

            if current_index >= len(queue):
                context.user_data.pop("awaiting_correction", None)
                return

            entry_idx, key = queue[current_index]

            # –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å
            entries[entry_idx][key] = user_input
            correction_data["current_index"] += 1

            # –ï—Å–ª–∏ –æ—Å—Ç–∞–ª–∏—Å—å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            if correction_data["current_index"] < len(queue):
                next_entry_idx, next_key = queue[correction_data["current_index"]]
                entry_number = next_entry_idx + 1
                await update.message.reply_text(
                    f"""–ó–∞–ø–∏—Å—å {entry_number}. –ù–µ—Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: ```
{entries[entry_number]['–î–∞–Ω–Ω—ã–µ']}```

–í–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—è '{next_key}':""",
                    parse_mode=constants.ParseMode.MARKDOWN,
                )
            else:
                # –í—Å–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω—ã
                context.user_data.pop("awaiting_correction", None)
                for entry in entries:
                    entry.pop("–î–∞–Ω–Ω—ã–µ", None)
                context.user_data["corrected_entries"] = entries

                # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –æ—Ç—á–µ—Ç
                formatted_report = (
                    "<pre>"
                    + "\n\n".join(
                        [
                            pd.DataFrame([entry]).to_string(index=False)
                            for entry in entries
                        ]
                    )
                    + "</pre>"
                )
                keyboard = [
                    [
                        InlineKeyboardButton(
                            "–§–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç—á—ë—Ç ‚úÖ", callback_data="final_yes"
                        ),
                        InlineKeyboardButton(
                            "–ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π –æ—Ç—á—ë—Ç ‚ö†Ô∏è", callback_data="final_no"
                        ),
                    ]
                ]
                reply_markup = InlineKeyboardMarkup(keyboard)
                await update.message.reply_text(
                    formatted_report, reply_markup=reply_markup, parse_mode="HTML"
                )
            return

        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
        chat_id = update.effective_chat.id
        query_text = message_text(update) or ""
        sent_message = None
        logger.info(
            f"New message received from user {update.message.from_user.name} (id: {update.message.from_user.id})"
        )

        # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–ª–æ–∂–µ–Ω–∏–π
        file = update.message.document
        photo = update.message.photo
        if file or photo:
            self.has_attachment = True
            sent_message = await update.effective_message.reply_text(
                "–§–∞–π–ª –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è ü§ñ", reply_to_message_id=update.message.message_id
            )
            try:
                file_content = await manage_attachment(
                    self.model, update, context, file, photo
                )
                logger.info(file_content)
                query_text = f"""[–¢–ê–ë–õ–ò–¶–ê]:\n{file_content}\n\n{query_text}"""

            except Exception:
                await edit_message_with_retry(
                    context,
                    chat_id,
                    str(sent_message.message_id),
                    "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –º–æ–¥–µ–ª—å –Ω–µ –º–æ–∂–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –¥–∞–Ω–Ω—ã–π —Ñ–∞–π–ª üò¢ –ü—Ä–∏–ª–æ–∂–∏—Ç–µ –æ—Ç—á—ë—Ç –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º –≤–∏–¥–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞.",
                )
                return

        # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç—á–µ—Ç–∞
        await update.effective_message.reply_chat_action(constants.ChatAction.TYPING)
        if not sent_message:
            sent_message = await update.effective_message.reply_text(
                "–§–æ—Ä–º–∏—Ä—É—é –æ—Ç—á—ë—Ç üìù", reply_to_message_id=update.message.message_id
            )
        else:
            await edit_message_with_retry(
                context,
                chat_id,
                str(sent_message.message_id),
                "–§–æ—Ä–º–∏—Ä—É—é –æ—Ç—á—ë—Ç üìù",
            )

        response = self.builder.build(query_text)
        formatted_report = ""

        if response != ERROR_TEXT:

            logger.info("Report ready!")
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π
            corrections_queue = []
            for entry_idx, entry in enumerate(response):
                for key, value in entry.items():
                    if value == "–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ":
                        corrections_queue.append((entry_idx, key))

            if corrections_queue:
                context.user_data["corrections"] = {
                    "entries": response,
                    "queue": corrections_queue,
                    "current_index": 0,
                }
                context.user_data["awaiting_correction"] = True
                first_entry_idx, first_key = corrections_queue[0]
                await update.message.reply_text(
                    f"""–ü—Ä–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–∏ –æ—Ç—á—ë—Ç–∞ –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è, —Ç—Ä–µ–±—É–µ—Ç—Å—è —É—Ç–æ—á–Ω–µ–Ω–∏–µ.

–ó–∞–ø–∏—Å—å {first_entry_idx + 1}. –ù–µ—Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: ```
{response[first_entry_idx]['–î–∞–Ω–Ω—ã–µ']}```

–í–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—è '{first_key}':
""",
                    parse_mode=constants.ParseMode.MARKDOWN,
                )
                return

            # –ï—Å–ª–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –Ω–µ —Ç—Ä–µ–±—É—é—Ç—Å—è
            for entry in response:
                entry.pop("–î–∞–Ω–Ω—ã–µ", None)

            formatted_report = (
                "<pre>"
                + "\n\n".join(
                    [pd.DataFrame([entry]).to_string(index=False) for entry in response]
                )
                + "</pre>"
            )
            keyboard = [
                [
                    InlineKeyboardButton(
                        "–§–∏–Ω–∞–ª—å–Ω—ã–π –æ—Ç—á—ë—Ç ‚úÖ", callback_data="final_yes"
                    ),
                    InlineKeyboardButton(
                        "–ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π –æ—Ç—á—ë—Ç ‚ö†Ô∏è", callback_data="final_no"
                    ),
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(
                formatted_report, reply_markup=reply_markup, parse_mode="HTML"
            )

        #             group_report = f"""–û—Ç—á—ë—Ç –æ—Ç {update.effective_user.full_name}:\n\n{formatted_report}
        # –ò—Å—Ö–æ–¥–Ω—ã–π —Ç–µ–∫—Å—Ç:

        # {query_text}"""
        #             await context.bot.send_message(
        #                 chat_id=self.config["group_chat_id"],
        #                 text=group_report,
        #                 parse_mode=constants.ParseMode.HTML,
        #                 disable_web_page_preview=True,
        #             )
        else:
            await edit_message_with_retry(
                context,
                chat_id,
                str(sent_message.message_id),
                response,
                html=True,
            )

    async def post_init(self, application: Application) -> None:
        """
        Post initialization hook for the bot.
        """
        await application.bot.set_my_commands(self.commands)

    def run(self):
        """
        Runs the bot indefinitely until the user presses Ctrl+C
        """
        application = (
            ApplicationBuilder()
            .token(self.config["token"])
            .post_init(self.post_init)
            .concurrent_updates(True)
            .build()
        )

        application.add_handler(CommandHandler("help", self.help))
        application.add_handler(CommandHandler("start", self.help))
        application.add_handler(
            CommandHandler(
                "chat",
                self.prompt,
                filters=filters.ChatType.GROUP | filters.ChatType.SUPERGROUP,
            )
        )
        application.add_handler(
            MessageHandler(
                (
                    filters.TEXT
                    | filters.FORWARDED
                    | filters.PHOTO
                    | filters.Document.ALL
                )
                & filters.ChatType.PRIVATE
                & (~filters.COMMAND),
                self.prompt,
            )
        )
        application.add_handler(
            CallbackQueryHandler(self.button_callback, pattern="^final_")
        )

        application.add_error_handler(error_handler)

        application.run_polling(allowed_updates=Update.ALL_TYPES)
